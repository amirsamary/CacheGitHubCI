<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Apple Mac OS X for x86-64) 2016.2 (Build 734U)" ts="2017-01-30 23:37:41">
<Class name="CacheGitHubCI.UDL">
<Super>%RegisteredObject</Super>
<TimeChanged>64313,85022.40077</TimeChanged>
<TimeCreated>64232,70931.608196</TimeCreated>

<Method name="IsUDLFile">
<Description><![CDATA[
Checks whether this file is in UDL format
<b>stream</b> - stream which contains file definition]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%GlobalCharacterStream</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// probably 10 lines is enough
	set counter = 0
	while 'stream.AtEnd {
		if counter >= 10 {
			quit
		}
		set line = stream.ReadLine()
		if $find(line, "<Export") {
			do stream.Rewind()
			return $$$NO
		}
		set counter = counter + 1
	}
	do stream.Rewind()

	return $$$YES
]]></Implementation>
</Method>

<Method name="ReadName">
<Description><![CDATA[
Finds the first string in a line
<b>line</b> - any string.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>line:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set trimmed = $zstrip(line, "<>W")
	return $piece(trimmed, " ")
]]></Implementation>
</Method>

<Method name="GetClassName">
<Description><![CDATA[
Finds a name of a class
<b>stream</b> - stream which contains a class definition<br>
<b>name</b> - name which contains the name of class<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[stream:%GlobalCharacterStream,&name:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do stream.Rewind()
	while 'stream.AtEnd {
		set line = stream.ReadLine()
		Set line = $ZStrip(line,"<>W") // I have seen the class keyword come with one or mor spaces before it...
		if $extract(line, 1, 3) = "///" { // check for inline comments
			continue
		} elseif $zconvert($extract(line, 1, 5), "l") = "class" {
			set line = $extract(line, 6, *)
			set name = ..ReadName(line)
			if name = "" {
				return $System.Status.Error(5001,"Could not determine class name from text: "_line)
			} else {
				return $$$OK
			}
		}
	}
	return $System.Status.Error(5001,"Could not determine class name.")
]]></Implementation>
</Method>

<Method name="GetRoutineName">
<Description><![CDATA[
Finds a name of a routine
<b>stream</b> - stream which contains a routine definition<br>
<b>name</b> - name which contains the name of routine<br>
<b>type</b> - type of file {1 - mac, 2 - inc, 3 - int}]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[stream:%GlobalCharacterStream,&name:%String,&type:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	while 'stream.AtEnd {
		set line = stream.ReadLine()
		set index = $find(line, "ROUTINE")
		// TODO - check whether the name on the next line
		// or something is between ROUTINE and name
		if index {
			if $find(line, "[Type=INC]") {
				set type = 2
			}
			elseif $find(line, "[Type=INT,Generated]") {
				set type = 3
			}
			else {
				set type = 1
			}
			set line = $extract(line, index, *)
			set name = ..ReadName(line)
			if name = "" {
				return '$$$OK
			} else {
				return $$$OK
			}
		}
	}
	return '$$$OK
]]></Implementation>
</Method>

<Method name="GetDFIName">
<Description><![CDATA[
Finds a name of a dfi
<b>stream</b> - stream which contains a dfi definition<br>
<b>name</b> - name which contains the name of dfi<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[stream:%GlobalCharacterStream,&name:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim textreader As %XML.TextReader
	set dfiContent = ""

	// I don't know why but if i just parse stream it doesn't work
	while 'stream.AtEnd {
		set dfiContent = dfiContent _ stream.Read()
	}

	set st = ##class(%XML.TextReader).ParseString(dfiContent, .textreader)
	return:$$$ISERR(st) st

	while textreader.Read() {
		set node = textreader.Name
		if (node = "pivot") || (node = "dashboard") {
			do textreader.MoveToAttributeName("folderName")
			set dfiFolderName = $translate(textreader.Value, " ", "-")

			do textreader.MoveToAttributeName("name")
			set dfiName = $translate(textreader.Value, " ", "-")

			set name = dfiFolderName _ "-" _ dfiName _ "." _ node _ ".dfi"
			return $$$OK
		}
	}
	return '$$$OK
]]></Implementation>
</Method>

<Method name="GetExt">
<Description><![CDATA[
Get extension of the file by url
<b>url</b> - the url where the file is located in the web.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>url:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//return $zconvert($piece(url, ".", *), "l")
	//AMIR: There are parameters after the extension that are not part of the extension
	return $zconvert($piece($piece(url, ".", *),"?"), "l")
]]></Implementation>
</Method>

<Method name="IsWebFile">
<Description><![CDATA[
Check whether a file is a web file
<b>ext</b> - extensions of the file<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ext:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set webExts = "csp,html,css,js,ts,scss"
	return $find(webExts, ext)
]]></Implementation>
</Method>

<Method name="LoadUDLFile">
<Description><![CDATA[
Imports the file in UDL file in the project
<b>contentStream</b> - the stream which contains the source code in udl format.<br>
<b>url</b> - the url where the file is located in the web.<br>
<b>list</b> - array of files to compile<br>
LoadUDDLFile is mirror aware now. If we are on a secondary node of a mirror, that won't allow us to
write into the database and the file on the link is a CachÃ© file that is loaded
inside the database (MAC, INT, CLS, DFI), it will simply skip it and return OK. If it is a HTML, JS,
PNG, etc. file, that can sit outside the database, the file will be generated as usual. If it is a CSP file
the file will be generated outside the database as usual but the GitHub.Update() method won't be loading/compiling them into
the database. That will be done by the primary mirror member when it downloads the file from github. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>contentStream:%GlobalCharacterStream,binaryStream:%Stream.FileCharacterGzip,url:%String,list:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	Try
	{
		set ext = ..GetExt(url)
		
		//Set bDBReadWrite = ..CanWriteOnCurrentNS()
		
		if (ext = "cls") 
		{
			Write " - CLS"
			//Set:bDBReadWrite tSC = ..CreateClass(contentStream, url, .list)
			Set tSC = ..CreateClass(contentStream, url, .list)
		}
		elseif (ext = "dfi") 
		{
			Write " - DFI"
			//Set:bDBReadWrite tSC = ..CreateDFI(contentStream, url, .list)
			Set tSC = ..CreateDFI(contentStream, url, .list)
		}
		elseif (ext = "inc") || (ext = "mac") 
		{
			Write " - RTN"
			//Set:bDBReadWrite tSC = ..CreateRoutine(contentStream, url, .list)
			Set tSC = ..CreateRoutine(contentStream, url, .list)
		}
		else
		{
			Write " - WEB"
			set tSC = ..CreateWebFile(contentStream, binaryStream, url, ext, .list)
		}
	}
	Catch (oException)
	{
		Set tSC = oException.AsStatus()
	}
	
	return tSC
]]></Implementation>
</Method>

<Method name="CanWriteOnCurrentNS">
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set bDBReadWrite=1
	If $System.Mirror.IsMember() && '$System.Mirror.IsPrimary()
	{
		//If we are part of a mirror and we are not the primary, we can't write to the
		//database. But, CGCI will be loading classes on the database on the primary member and we,
		//as secondary member, will be receiving those. So, we must only load on the secondary
		//member, files that stay outside of the database.
		Set bDBReadWrite=0
	}
	
	Quit bDBReadWrite
]]></Implementation>
</Method>

<Method name="DoesClassExist">
<Description><![CDATA[
Checks whether the class exists
<b>className</b> - name of the class.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set query = "SELECT TOP 1 COUNT(ID) FROM %Dictionary.ClassDefinition WHERE ID = ?"
	Set statement = ##class(%SQL.Statement).%New()
	Set st = statement.%Prepare(query)
	Set rset = statement.%Execute(className)
	If (rset.%Next()) && (rset.%ROWCOUNT > 0) {
		Return $$$YES
	}
	Return $$$NO
]]></Implementation>
</Method>

<Method name="CreateClass">
<Description><![CDATA[
Creates and imports the class into the project from stream
<b>contentStream</b> - the stream which contains the source code in udl format.<br>
<b>url</b> - the url where the file is located in the web.<br>
<b>list</b> - array of files to compile<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[contentStream:%CharacterStream,url:%String,&list:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set st = ..GetClassName(contentStream, .className)
	Return:$$$ISERR(st) st

	set list(className _ ".cls") = ""

	Do contentStream.Rewind()

	If '..DoesClassExist(className) {
		Set clsDef = ##class(%Dictionary.ClassDefinition).%New()
		Set clsDef.Name = className
		Set st = clsDef.%Save()
		Return:$$$ISERR(st) st
	}


	Set namespace = $namespace
	Set st = ##class(%Compiler.UDL.TextServices).SetTextFromStream(namespace, className, contentStream)

	if st {
		w !, "Imported " _ className, !
	}

	Return st
]]></Implementation>
</Method>

<Method name="CreateDFI">
<Description><![CDATA[
Creates and imports the dfi file into the project from stream
<b>contentStream</b> - the stream which contains the source code in udl format.<br>
<b>list</b> - array of files to compile<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[contentStream:%CharacterStream,url:%String,&list:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set st = $$$OK
    Try {
	    Set st = ..GetDFIName(contentStream, .name)
	    Return:$$$ISERR(st) st

	    set list(name) = ""

        Set tDoc = ##class(%DeepSee.UI.FolderItemDocument).%New(name)
        Set st = tDoc.ImportFromXML(contentStream)
        Return:$$$ISERR(st) st

        Set st = tDoc.Save()
        if st {
		w !, "Imported " _ name, !
	}
        Return:$$$ISERR(st) st
    } Catch e {
        Set st = e.AsStatus()
    }
    Return st
]]></Implementation>
</Method>

<Method name="CreateRoutine">
<Description><![CDATA[
Creates and imports mac, int, inc files into the project from stream
<b>contentStream</b> - the stream which contains the source code in udl format.<br>
<b>url</b> - the url where the file is located in the web.<br>
<b>list</b> - array of files to compile<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[contentStream:%GlobalCharacterStream,url:%String,&list:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set st = ..GetRoutineName(contentStream, .name, .type)
	do contentStream.Rewind()

	return:$$$ISERR(st) st

	if type = 1 {
		set name = name _ ".mac"
	}
	elseif type = 2 {
		set name = name _ ".inc"
	}
	elseif type = 3 {
		set name = name _ ".int"
	}

	set list(name) = ""

	Set rtn = ##class(%Routine).%New(name)
	While 'contentStream.AtEnd {
		Set line = contentStream.ReadLine()
		If $Find(line, "ROUTINE") {
			Continue
		}
		Do rtn.WriteLine(line)
	}

	Set st = rtn.Save()
 	Return:$$$ISERR(st) st

 	if st {
		w !, "Imported " _ name, !
	}
 	Return st
]]></Implementation>
</Method>

<Method name="CreateWebFile">
<Description><![CDATA[
Creates and imports mac, int, inc files into the project from stream
<b>contentStream</b> - the stream which contains the source code in udl format.<br>
<b>url</b> - the url where the file is located in the web.<br>
<b>ext</b> - extension of the file<br>
<b>list</b> - array of files to compile<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[contentStream:%GlobalCharacterStream,binaryStream:%Stream.FileCharacterGzip,url:%String,ext:%String,&list:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set st = $$$OK
	Try
	{
		// tDefaultApp will contain the CSP Default Application for this namespace
		// Something like /csp/myapp/
		//Set tDefaultApp=$system.CSP.GetDefaultApp($namespace)_"/"

		// tCSPRootPath will contain something like:
		// https://raw.githubusercontent.com/rcruzat/ISP/master/ISP/CSP/csp/isp/ui/login.csp?token=AGE9JIrxup6i6gQkPcBz6Aeh4qoQvVDoks5Yj7cswA%3D%3D
		// Where each piece means:
		// 1- https:
		// 2- 
		// 3- raw.githubusercontent.com
		// 4- github repository owner
		// 5- github repository name
		// 6- branch
		// 7- Atelier project name
		// 8- Atelier file type (CSP)
		
		set tFullCSPFileName = "/"_$Piece($Piece(url, "/", 9, *),"?")		
		Set tFullPhysicalFileName = $system.CSP.GetFileName(tFullCSPFileName)
		If tFullPhysicalFileName["/"
		{
			Set tSeparator="/"
		}
		Else
		{
			Set tSeparator="\"
		}
		set tPhysicalPath = $Piece(tFullPhysicalFileName,tSeparator,1,*-1)_tSeparator
		
		Set tFileName = $Piece(tFullCSPFileName,"/",*)
		If ",.gitattributes,.gitignore,.settings"[(","_tFileName_",")
		{
			Write !,"Ignoring file ",tFullCSPFileName
			Quit
		}
		Set tFileExtension = $ZConvert($Piece(tFileName,".",*),"L")

		If '##class(%File).CreateDirectoryChain(tPhysicalPath)
		{
			Set st = $System.Status.Error(5001,"Could nor create path chain '"_tPhysicalPath_"'")
			Quit
		}

		If $IsObject(contentStream) && ..IsWebFile(ext)
		{
			Set filestream = ##class(%Stream.FileCharacter).%New()
			set st = filestream.LinkToFile(tFullPhysicalFileName)
			Quit:$System.Status.IsError(st)

			Set st=filestream.CopyFrom(contentStream)
		}
		Else
		{
			Set filestream = ##class(%Stream.FileBinary).%New()
			set st = filestream.LinkToFile(tFullPhysicalFileName)
			Quit:$System.Status.IsError(st)

			Set st=filestream.CopyFrom(binaryStream)
		}
		Quit:$System.Status.IsError(st)

		set st = filestream.%Save()
		Quit:$System.Status.IsError(st)

		// If this CSP file is a "csp" file, then we must queue it for compilation.
		If tFileExtension="csp"
		{
			Set list(tFullCSPFileName)=""
		}

		Write !, "Imported " _ tFullCSPFileName, !
	}
	Catch (oException)
	{
		Set st = oException.AsStatus()
	}
	
	If $System.Status.IsError(st) && ($Get(tFullCSPFileName)'="")
	{
		Write !,"Error while importing " _ tFullCSPFileName
	}
	
	Quit st
]]></Implementation>
</Method>
</Class>
</Export>
