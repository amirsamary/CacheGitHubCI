<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="CacheGitHubCI.GitHub">
<Super>%RegisteredObject,CacheGitHubCI.UDL</Super>
<TimeCreated>64232,70929.42371</TimeCreated>

<Method name="GetLocalIP">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Return:($d(^CacheGitHubCI("IP"))) ^CacheGitHubCI("IP")
	Return $SYSTEM.INetInfo.HostNameToAddr($SYSTEM.INetInfo.LocalHostName()) // unreliable
]]></Implementation>
</Method>

<Method name="CreateRequest">
<ClassMethod>1</ClassMethod>
<FormalSpec>Username:%String,Password:%String,pProxy:%String=""</FormalSpec>
<ReturnType>%Net.HttpRequest</ReturnType>
<Implementation><![CDATA[
	#Dim req As %Net.HttpRequest
	Set namespace = $Namespace
 	Set SSLConfig = "GitHub"

 	Zn "%SYS" 
 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)
 	Zn namespace

 	Set req=##class(%Net.HttpRequest).%New()
 	Set req.Https=1
 	If pProxy'=""
 	{
	 		Set req.ProxyServer=$Piece(pProxy,":",1)
	 		Set req.ProxyPort=$Piece(pProxy,":",2)
	 		Set req.ProxyHTTPS=1
	 		Set req.ProxyTunnel=1
 	}

	Set req.SSLConfiguration=SSLConfig
	Set req.Server="api.github.com"
	Do req.SetHeader("Accept","application/vnd.github.v3+json") 			// we want 3rd version of api

	If ($d(Username) && $d(Password) && (Username'="") && (Password'="")) {	// supply Username and Passwor, if both are provided. GitHub accept Basic Auth
		Set req.Username = Username											// https://developer.github.com/v3/auth/
	 	Set req.Password = Password
	}

	Return req
]]></Implementation>
</Method>

<Method name="CreateHook">
<ClassMethod>1</ClassMethod>
<FormalSpec>Owner:%String,Repository:%String,Username:%String="",Password:%String="",Namespace=$Namespace,pProxy:%String="",*HookId</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim req As %Net.HttpRequest
	Set tSC = $System.Status.OK()
	Try
	{
		Set req = ..CreateRequest(Username, Password, pProxy)
		Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/hooks"
	
		Set hook = ##class(%ZEN.proxyObject).%New()
		Set hook.name = "web"
		//set hook.active = 1 // can't supply js true/false. True by default
		Set hook.events = ##class(%ListOfDataTypes).%New()
		Do hook.events.Insert("push")
		Set hook.config = ##class(%ZEN.proxyObject).%New()
		Set hook.config.url = "http://" _..GetLocalIP() _"/cgci/receive/"_ Owner _ "/" _ Repository _"/" _ Namespace
		Set hook.config."content_type" = "json"
		Set hook.config."insecure_ssl" = 1
		
		Set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%WriteJSONStreamFromObject(req.EntityBody,hook)
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = req.Post()
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = ..EvaluateHttpResponseStatusCode(req, 201)
		Quit:$System.Status.IsError(tSC)

		Set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(req.HttpResponse.Data,,.obj,1)
		Quit:$System.Status.IsError(tSC)
		
		Set HookId = obj.id
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	Return tSC
]]></Implementation>
</Method>

<Method name="DeleteHook">
<ClassMethod>1</ClassMethod>
<FormalSpec>Owner:%String,Repository:%String,Username:%String="",Password:%String="",HookId:%Integer,pProxy:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim req As %Net.HttpRequest
	Set tSC = $System.Status.OK()
	Try
	{
		Set req = ..CreateRequest(Username, Password, pProxy)
		Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/hooks/" _ HookId

		Set tSC = req.Send("DELETE","")

		Set tSC = req.Get()
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = ..EvaluateHttpResponseStatusCode(req, 204)
		Quit:$System.Status.IsError(tSC)
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	Return tSC
]]></Implementation>
</Method>

<Method name="GetHooks">
<ClassMethod>1</ClassMethod>
<FormalSpec>Owner:%String,Repository:%String,Username:%String="",Password:%String="",Namespace=$Namespace,*Hooks,pProxy:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim objects As List of %ZEN.proxyObject
	Set tSC = $System.Status.OK()
	Try
	{
		Set req = ..CreateRequest(Username, Password, pProxy)
		Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/hooks"
	
		Set tSC = req.Get()
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = ..EvaluateHttpResponseStatusCode(req)
		Quit:$System.Status.IsError(tSC)
	
		Set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(req.HttpResponse.Data,,.Hooks,1)
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	Return tSC
]]></Implementation>
</Method>

<Method name="GetLastCommit">
<ClassMethod>1</ClassMethod>
<FormalSpec>Owner:%String,Repository:%String,Branch:%String="master",Username:%String="",Password:%String="",pProxy:%String="",*Commit:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $System.Status.OK()
	Try
	{
		kill Commit
		Set req = ..CreateRequest(Username, Password, pProxy)
		Set:(Branch="") Branch="HEAD" // Branch does not automatically elevates to master
		Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/commits/" _ Branch
	
		Set tSC = req.Get()
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = ..EvaluateHttpResponseStatusCode(req)
		Quit:$System.Status.IsError(tSC)
		
		Set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(req.HttpResponse.Data,,.Commit,1)
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	Return tSC
]]></Implementation>
</Method>

<Method name="Update">
<Description><![CDATA[
Downloads and compiles GitHub repository.<br>
<b>Owner</b> - The name of the repository owner.<br>
<b>Repository</b> - The name of the repository.<br>
<b>Branch</b> - The name of the commit/branch/tag. If skipped the repository’s default branch (usually master) would be used.<br>
<b>Username</b> - GitHub user, who has access to repository. Optional for public repositories.<br>
<b>Password</b> - GitHub password, corresponding to Username. Optional for public repositories.<br>
Note, that with Username, you can make up to 5,000 requests per hour.
For unauthenticated requests, the rate limit allows to make up to 60 requests per hour.
Unauthenticated requests are associated with an IP address.<br>
<b>Namespace</b> - Namespace, where to download and compile repository.<br>

For example in the repository: https://github.com/intersystems-ru/Cache-MDX2JSON<br>
Owner - intersystems-ru, Repository - Cache-MDX2JSON.<br> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Owner:%String,Repository:%String,Branch:%String="",Username:%String="",Password:%String="",Namespace=$Namespace,pProxy:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim req As %Net.HttpRequest
	Set tSC = $System.Status.OK()
	Try
	{
		Set tCGCINamespace = $Namespace
		
		Set req = ..CreateRequest(Username, Password, pProxy)
		Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents" 	// as described in https://developer.github.com/v3/repos/

		Set links = ##class(%ListOfDataTypes).%New()
		
		Write !,"Process directory..."
		Set tSC = ..ProcessDirectory("",.req,Branch,Namespace,.links)
		Quit:$System.Status.IsError(tSC)
		
		Write !,"Downloading files..."
		Set tSC = ..DownloadFiles(links,req,.list,Namespace)
		Quit:$System.Status.IsError(tSC)
		
		Zn Namespace
		Write !,"Compiling classes..."
		Set tSC = $system.OBJ.CompileList(.list,"brucky /checkuptodate=expandedonly")
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	ZN tCGCINamespace
	Quit tSC
]]></Implementation>
</Method>

<Method name="EvaluateHttpResponseStatusCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHTTPRequest:%Net.HttpRequest,pExpectedStatusCode:%String="200"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tHTTPStatusCode = pHTTPRequest.HttpResponse.StatusCode	

	If tHTTPStatusCode=404
	{
		Return $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	}
	ElseIf ((tHTTPStatusCode=403) && (pHTTPRequest.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) 
	{
		Return $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
	}
	ElseIf (tHTTPStatusCode'= pExpectedStatusCode) 
	{
		Return $$$ERROR($$$GeneralError,"Received "_pStatusCode_" expected "_pExpectedStatusCode)
	}
	
	Return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessDirectory">
<Description><![CDATA[
Process one directory of GitHub repository. Recursive.<br>
<b>Path</b> -Internal repository path. Root is empty string<br>
<b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
<b>Links</b> - List of links to raw files (which satisfy <b>IsCacheFile</b> conditions) from repository.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Path:%String="",Request:%Net.HttpRequest,Branch:%String="",pTargetNamespace:%String,&Links:%ListOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	#dim objects As List of %ZEN.proxyObject
 	#dim obj As %ZEN.proxyObject

	Set tSC = $System.Status.OK()
	Try
	{
		Set location = Request.Location
		Set Request.Location = Request.Location _ Path
		If (Branch'="") Do Request.SetParam("ref",Branch)

		Set tSC = Request.Get()
		Quit:$System.Status.IsError(tSC)
	
		Set tSC = ..EvaluateHttpResponseStatusCode(Request)
		Quit:$System.Status.IsError(tSC)
	
		Set tSC = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,,.objects,1)
		Quit:$System.Status.IsError(tSC)

		Write !,Request.Location
		For i = 1:1:objects.Count()
		{
			Set obj = objects.GetAt(i)
			If (obj.type = "dir")
			{
				If $Extract(obj.name)'="."
				{
					Set tSC = ..ProcessDirectory("/"_obj.name,Request,Branch,pTargetNamespace,.Links)
				}
				Else
				{
					Write !,"Ignoring hidden directory ",Request.Location _ Path_"/"_obj.name,"..."
				}
				Quit:$System.Status.IsError(tSC)
			}
			ElseIf (obj.type = "file")
			{
				Set bIsCacheFile = ..IsCacheFile(obj)
				If ..FileHasChanged(pTargetNamespace, obj.path, obj.sha)
				{
					Write "."
					Do Links.Insert($LB(obj."download_url",bIsCacheFile,obj.path, obj.sha))
				}
			}
			Else
			{
				// obj.type = "symlink" or obj.type = "submodule"
			}
		}
		Quit:$System.Status.IsError(tSC)
		
		Set Request.Location = location // to keep track of where in the repository tree we are
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	Return tSC
]]></Implementation>
</Method>

<Method name="FileHasChanged">
<Description>
This method is used by ProcessDirectory() to determine if a file has
changed since the last download. 
pIsCacheFile will allow us to know if we can download this file or not. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetNamespace:%String,pFullFileName:%String,pFileHash:%String</FormalSpec>
<Implementation><![CDATA[
	Set tFullFileNameHash = $System.Encryption.SHA1Hash(pFullFileName)
	If $Get(^CGCIFileHash(pTargetNamespace,tFullFileNameHash))=pFileHash Return 0

	Return 1
]]></Implementation>
</Method>

<Method name="RegisterFileChanged">
<Description>
This method is called from DownloadFiles() to register a file that has just been
downloaded from the server. The idea is that on the next synchronization with GitHub
ProcessDirectory() will only queue for downloading files that are not registered (new files)
or are registered but are different from the last download (changed files).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetNamespace:%String,tFileFullName:%String,tFileHash:%String</FormalSpec>
<Implementation><![CDATA[
	Set tFullFileNameHash = $System.Encryption.SHA1Hash(tFileFullName)
	Set ^CGCIFileHash(pTargetNamespace,tFullFileNameHash)=tFileHash
]]></Implementation>
</Method>

<Method name="IsCacheFile">
<Description>
Check that incoming file is the one you need.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>File:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,dfi,pivot,dashboard,html,css,js,ts,scss,"
	Return:($L(File.name,".")=1) 0 //no extension
	Set File.Extension = $P(File.name,".",$L(File.name,"."))
	Return $F(extensions,","_$ZCVT(File.Extension,"l")_",")
]]></Implementation>
</Method>

<Method name="DownloadFiles">
<Description><![CDATA[
Download list of files on https://raw.githubusercontent.com/ server.<br>
<b>Links</b> - List of links to raw files.<br>
<b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
<b>loadedlist</b> - Returns an array of the items loaded. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Links:%ListOfDataTypes,Request:%Net.HttpRequest,*Items,pTargetNamespace:%String="CGCI"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Items
	Set Request.Server = "raw.githubusercontent.com"
	Set tSC = $$$OK
	Try
	{
		Set tNS = $Namespace
		
		Write !,"DonwloadFiles - > Links.Count: ",Links.Count()
		
		For i = 1:1:Links.Count()
		{
			Set link = $ListGet(Links.GetAt(i),1)
			Set bIsCacheFile = $ListGet(Links.GetAt(i),2)
			Set tFileFullName = $ListGet(Links.GetAt(i),3)
			Set tFileHash = $ListGet(Links.GetAt(i),4)
			
			Write !!,tFileFullName
			Set tSCReq = Request.Get($e(link,35,*)) // Remove "https://raw.githubusercontent.com/" from URL.
			If $$$ISERR(tSCReq)
			{
				Write !,$C(9),"Error al descargar contenido: ",$System.Status.GetErrorText(tSCReq)
				Set tSC=$$$ADDSC(tSC, tSCReq)
				Continue
			}
			
			Set tSCReq = ..EvaluateHttpResponseStatusCode(Request)
			If $$$ISERR(tSCReq)
			{
				Write !,$C(9),"Status diferente de 200 al descargar contenido: ",$System.Status.GetErrorText(tSCReq)
				Set tSC=$$$ADDSC(tSC, tSCReq)
				Continue
			}

			Set binarystream = Request.HttpResponse.Data

			Do binarystream.Rewind() // just in case

			Set characterStream=##class(%GlobalCharacterStream).%New() //translating binary stream into character stream
			Set tSCTranslate=$$$OK
			Try
			{
				While 'binarystream.AtEnd
				{
					//Use eol to prevent breaking lines larger than 32Kb
					Set line=binarystream.ReadLine(, .tSCTranslate, .eol)
					Quit:$System.Status.IsError(tSCTranslate)

					If eol
					{
						Set tSCTranslate=characterStream.WriteLine(line)
					}
					Else
					{
						Set tSCTranslate=characterStream.Write(line)
					}
					Quit:$System.Status.IsError(tSCTranslate)
				}
				Quit:$System.Status.IsError(tSCTranslate)

				Do characterStream.Rewind()
			}
			Catch (oTranslateStreamException)
			{
				Set tSCTranslate=oTranslateStreamException.AsStatus()
			}

			If $System.Status.IsError(tSCTranslate)
			{
				//Could not convert binary stream to character stream
				//It is probably a binary file anyway
				Set characterStream=""
				Set tSC=$$$ADDSC(tSC, tSCTranslate)
			}

			Do binarystream.Rewind()

			Set tSCLoad = $$$OK

			set items = ""
			ZN pTargetNamespace
			If ('$IsObject(characterStream)) || (..IsUDLFile(characterStream))
			{
				Write " - UDL"
				// LoadUDDLFile is mirror aware now. If we are on a secondary node of a mirror, that won't allow us to
				// write into the database and the file on the link is a Caché file that is loaded
				// inside the database (MAC, INT, CLS, DFI), it will simply skip it and return OK. If it is a HTML, JS,
				// PNG, etc. file, that can sit outside the database, the file will be generated as usual. If it is a CSP file
				// the file will be generated outside the database as usual but the Update() method won't be loading them into
				// the database. That will be done by the primary mirror member when it downloads the file from github. 
				Set tSCLoad = ..LoadUDLFile(characterStream, binarystream, link, .items)
			}
			ElseIf bIsCacheFile
			{
				Write " - XML"
				//Unfortunately LoadStream will always verify if the database can be written and refrain
				//to generate CSP, Js, Html, etc. files... So, working with XML will remain incompatible with mirroring.
				Set tSCLoad = $system.OBJ.LoadStream(characterStream,"",.error,.items,,,,"UTF8")
			}
			
			ZN tNS
			
	 		If $$$ISERR(tSCLoad)
	 		{
		 		Set tSC=$$$ADDSC(tSC, tSCLoad)
		 		Continue
	 		}
	 		Else
	 		{
		 		Do ..RegisterFileChanged(pTargetNamespace, tFileFullName, tFileHash)
	 		}
	 		Merge Items = items  // Does not overwrite existing array keys: Items(itemname)=""
		}

		Set Request.Server="api.github.com"
	}
	Catch (oException)
	{
		Set tSC=$$$ADDSC(tSC, oException.AsStatus())
	}
	
	ZN tNS
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Debug">
<Description>
This is a helper method only used when debugging code. It should not
be called from anywhere on production code.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStringOrStream</FormalSpec>
<Implementation><![CDATA[
	Quit:pStringOrStream=""
	If '$IsObject(pStringOrStream)
	{
		Set ^CGCIDebug($I(^CGCIDebug))=pStringOrStream
	}
	Else
	{
		Do pStringOrStream.Rewind()
		Set ^CGCIDebug($I(^CGCIDebug))=pStringOrStream.Read(32000)
		Do pStringOrStream.Rewind()
	}
]]></Implementation>
</Method>
</Class>
</Export>
